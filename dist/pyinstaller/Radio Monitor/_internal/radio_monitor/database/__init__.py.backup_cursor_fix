"""
Database package for Radio Monitor 1.0

This package provides a modular database interface with:
- schema.py: Database table definitions
- migrations.py: Schema migration functions
- queries.py: SELECT query methods
- crud.py: INSERT/UPDATE/DELETE operations
- exports.py: Lidarr/Plex export functions
- activity.py: Activity logging functions

The main RadioDatabase class (below) provides a unified interface
to all database operations with backward compatibility.

Schema Version: 9 (Manual MBID Overrides)
"""

import sqlite3
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

# Import schema functions
from .schema import create_tables, populate_stations
# Import migration functions
from .migrations import _initialize_schema
# Import query functions
from . import queries
# Import CRUD functions
from . import crud
# Import export functions
from . import exports


class RadioDatabase:
    """SQLite database with 11-table schema

    This is the main database interface that provides backward compatibility
    with the original database.py module while using the refactored submodules.

    Tables:
    - stations: Radio station metadata
    - artists: Artist information (MBID as primary key)
    - songs: Song catalog
    - song_plays_daily: Daily play tracking
    - schema_version: Schema version tracking
    - playlists: Unified playlists (manual + auto)
    - activity_log: System activity and event tracking
    - plex_match_failures: Plex matching failure tracking
    - notifications: Notification configurations
    - notification_history: Notification send history
    - manual_mbid_overrides: User-specified MBID mappings (v9)
    - ai_playlist_generations: AI playlist generation tracking (v10)
    """

    # Current schema version
    SCHEMA_VERSION = 10

    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = None
        self.cursor = None

    def connect(self):
        """Connect to database and create/update schema if needed"""
        # Allow connection to be used across threads (required for Flask multi-threading)
        self.conn = sqlite3.connect(self.db_path, check_same_thread=False)
        self.cursor = self.conn.cursor()

        # Enable foreign keys
        self.cursor.execute("PRAGMA foreign_keys = ON")

        # Check if we need to migrate or create schema
        _initialize_schema(self.cursor, self.conn, self.db_path, self.SCHEMA_VERSION)

    def get_cursor(self):
        """Get a new cursor for the current request

        This creates a fresh cursor for each request to avoid 'Recursive use of cursors' errors
        when multiple Flask requests use the database simultaneously.
        """
        return self.conn.cursor()

    # ==================== STATION METHODS ====================

    def get_all_stations(self):
        """Get all stations with health status"""
        cursor = self.conn.cursor()
        try:
            return queries.get_all_stations(cursor)
        finally:
            cursor.close()

    def get_station(self, station_id):
        """Get station by ID"""
        cursor = self.conn.cursor()
        try:
            return queries.get_station_by_id(cursor, station_id)
        finally:
            cursor.close()

    def get_all_stations_with_health(self):
        """Get all stations with health status"""
        cursor = self.conn.cursor()
        try:
            return queries.get_all_stations_with_health(cursor)
        finally:
            cursor.close()

    def get_station_health(self, station_id):
        """Get health status for a single station"""
        cursor = self.conn.cursor()
        try:
            return queries.get_station_health(cursor, station_id)
        finally:
            cursor.close()

    def add_station(self, station_id, name, url, genre, market, has_mbid=False, scraper_type='iheart', wait_time=10):
        """Add a new station to the database"""
        return crud.add_station(self.cursor, self.conn, station_id, name, url, genre, market,
                              has_mbid, scraper_type, wait_time)

    def delete_station(self, station_id):
        """Delete a station from the database"""
        return crud.delete_station(self.cursor, self.conn, station_id)

    def get_station_config(self, station_id):
        """Get station scraper configuration"""
        cursor = self.conn.cursor()
        try:
            return queries.get_station_config(cursor, station_id)
        finally:
            cursor.close()

    def update_station_failure(self, station_id, failed):
        """Update station failure tracking"""
        if failed:
            return crud.increment_station_failure_count(self.cursor, self.conn, station_id)
        else:
            crud.record_scrape_success(self.cursor, self.conn, station_id)

    def disable_station(self, station_id):
        """Disable a station (after too many failures)"""
        crud.disable_station(self.cursor, self.conn, station_id)

    def enable_station(self, station_id):
        """Enable a station"""
        crud.enable_station(self.cursor, self.conn, station_id)

    # ==================== ARTIST METHODS ====================

    def add_artist(self, mbid, name, first_seen_station):
        """Add or update artist"""
        return crud.add_artist(self.cursor, self.conn, mbid, name, first_seen_station)

    def get_artist_by_name(self, name):
        """Get artist by name"""
        return queries.get_artist_by_name(self.cursor, name)

    def get_artist_by_mbid(self, mbid):
        """Get artist by MBID"""
        return queries.get_artist_by_mbid(self.cursor, mbid)

    def get_all_artists(self):
        """Get all artists"""
        return queries.get_all_artists(self.cursor)

    def update_artist_mbid(self, artist_name, mbid):
        """Update artist MBID (DEPRECATED - use update_artist_mbid_from_pending)"""
        logger.warning("update_artist_mbid is deprecated, use update_artist_mbid_from_pending instead")
        # Still implement for backward compatibility
        self.cursor.execute("""
            UPDATE artists
            SET mbid = ?
            WHERE name = ? AND mbid IS NULL
        """, (mbid, artist_name))
        self.conn.commit()
        return self.cursor.rowcount > 0

    def update_artist_mbid_from_pending(self, artist_name, mbid):
        """Update artist MBID (for resolving NULL or PENDING MBIDs)"""
        return crud.update_artist_mbid_from_pending(self.cursor, self.conn, artist_name, mbid)

    def get_pending_artists(self):
        """Get all artists with PENDING MBIDs"""
        return queries.get_pending_artists(self.cursor)

    def mark_artist_imported_to_lidarr(self, mbid):
        """Mark artist as imported to Lidarr"""
        return crud.mark_single_artist_imported_to_lidarr(self.cursor, self.conn, mbid)

    def mark_artists_imported(self, mbids):
        """Mark multiple artists as imported to Lidarr"""
        return crud.mark_artists_imported_to_lidarr(self.cursor, self.conn, mbids)

    def reset_all_lidarr_import_status(self):
        """Reset all artists to "Needs Import" status

        Useful when sharing databases with friends or re-importing to Lidarr.

        Returns:
            Number of artists reset
        """
        return crud.reset_all_lidarr_import_status(self.cursor, self.conn)

    def delete_pending_artists_older_than(self, days=30):
        """Delete PENDING artists older than specified days

        Args:
            days: Delete artists older than this many days (default: 30)

        Returns:
            Number of artists deleted
        """
        return crud.delete_pending_artists_older_than(self.cursor, self.conn, days)

    def get_artists_for_import(self, min_plays=5, station_id=None, sort='total_plays', direction='desc'):
        """Get artists that need Lidarr import

        Args:
            min_plays: Minimum total plays (default: 5)
            station_id: Optional station ID to filter by
            sort: Column to sort by (default: 'total_plays')
            direction: Sort direction 'asc' or 'desc' (default: 'desc')
        """
        cursor = self.conn.cursor()
        try:
            return queries.get_artists_for_import(cursor, min_plays, station_id, sort, direction)
        finally:
            cursor.close()

    # ==================== SONG METHODS ====================

    def add_song(self, artist_mbid, artist_name, song_title, station_id=None):
        """Add or update song"""
        return crud.add_song(self.cursor, self.conn, artist_mbid, artist_name, song_title, station_id)

    def get_song_by_id(self, song_id):
        """Get song by ID"""
        return queries.get_song_by_id(self.cursor, song_id)

    def get_all_songs(self, station_id=None):
        """Get all songs for export"""
        return queries.get_all_songs(self.cursor, station_id)

    def increment_play_count(self, date, hour, song_id, station_id):
        """Increment play count for a song on a specific date/hour/station"""
        crud.increment_play_count(self.cursor, self.conn, date, hour, song_id, station_id)

    # ==================== QUERY METHODS ====================

    def get_stats(self):
        """Get database statistics"""
        cursor = self.conn.cursor()
        try:
            return queries.get_statistics(cursor)
        finally:
            cursor.close()

    def get_top_songs(self, days=None, station_id=None, station_ids=None, limit=50):
        """Get top songs by play count"""
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_top_songs(cursor, days, station_id, station_ids, limit)
        finally:
            cursor.close()

    def get_recent_songs(self, days=None, station_ids=None, limit=50):
        """Get most recently played songs"""
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_recent_songs(cursor, days, station_ids, limit)
        finally:
            cursor.close()

    def get_top_artists(self, days=None, station_ids=None, limit=50):
        """Get top artists by play count"""
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_top_artists(cursor, days, station_ids, limit)
        finally:
            cursor.close()

    def get_trending_songs(self, days=90):
        """Get trending songs (recent plays vs older plays)"""
        return queries.get_trending_songs(self.cursor, days)

    # ==================== EXPORT METHODS ====================

    def export_to_json(self, output_file, station_id=None):
        """Export database to JSON"""
        return exports.export_to_json(self.cursor, output_file, station_id)

    def get_artists_for_lidarr_export(self, station_id=None):
        """Get artists for Lidarr export"""
        return exports.get_artists_for_lidarr_export(self.cursor, station_id)

    def get_songs_for_plex_export(self, station_ids=None, min_plays=1, max_plays=None, days=None,
                                  mode='merge', limit=None):
        """Get songs for Plex playlist export"""
        return exports.get_songs_for_plex_export(self.cursor, station_ids, min_plays, max_plays,
                                                days, mode, limit)

    # ==================== GUI METHODS ====================

    def get_recent_plays(self, limit=10, station_id=None):
        """Get recent plays for dashboard live feed

        Args:
            limit: Maximum number of plays to return (default: 10)
            station_id: Filter by specific station ID (default: None = all stations)
        """
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_recent_plays(cursor, limit, station_id)
        finally:
            cursor.close()

    # ==================== CHART QUERY METHODS ====================

    def get_plays_over_time(self, days=30, station_id=None):
        """Get play counts over time for line chart

        Args:
            days: Number of days to look back (default: 30)
            station_id: Filter by specific station (optional)
        """
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_plays_over_time(cursor, days, station_id)
        finally:
            cursor.close()

    def get_station_distribution(self, days=None):
        """Get play distribution by station for pie chart

        Args:
            days: Number of days to look back (None = all time)
        """
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_station_distribution(cursor, days)
        finally:
            cursor.close()

    def get_daily_plays_chart_data(self, days=30):
        """Get daily plays for chart"""
        return queries.get_daily_plays_chart_data(self.cursor, days)

    def get_hourly_plays_chart_data(self):
        """Get hourly plays for heat map"""
        return queries.get_hourly_plays_chart_data(self.cursor)

    def get_dashboard_stats(self):
        """Get dashboard statistics"""
        return queries.get_dashboard_stats(self.cursor)

    # ==================== STATION HEALTH TRACKING METHODS ====================

    def record_scrape_success(self, station_id):
        """Record successful scrape for a station"""
        crud.record_scrape_success(self.cursor, self.conn, station_id)

    def record_scrape_failure(self, station_id):
        """Record failed scrape for a station"""
        return crud.record_scrape_failure(self.cursor, self.conn, station_id)

    # ==================== SCRAPING HELPER METHODS ====================

    def get_station_by_id(self, station_id):
        """Get station information by ID"""
        return queries.get_station_by_id(self.cursor, station_id)

    def add_artist_if_new(self, mbid, name):
        """Add artist to database if not already present"""
        return crud.add_artist_if_new(self.cursor, self.conn, mbid, name)

    def add_song_if_new(self, artist_mbid, song_title):
        """Add song to database if not already present"""
        return crud.add_song_if_new(self.cursor, self.conn, artist_mbid, song_title)

    def record_play(self, song_id, station_id, play_count=1):
        """Record a play for a song on a station"""
        return crud.record_play(self.cursor, self.conn, song_id, station_id, play_count)

    # ==================== PLAYLISTS (Unified: Manual + Auto) ====================

    def add_playlist(self, name, is_auto, interval_minutes=None, station_ids=None, max_songs=None, mode=None,
                     min_plays=1, max_plays=None, days=None, enabled=True):
        """Add a new playlist (manual or auto)"""
        return crud.add_playlist(self.cursor, self.conn, name, is_auto, interval_minutes, station_ids,
                               max_songs, mode, min_plays, max_plays, days, enabled)

    def get_playlists(self):
        """Get all playlists (manual and auto)"""
        cursor = self.conn.cursor()
        try:
            return queries.get_playlists(cursor)
        finally:
            cursor.close()

    def get_playlist(self, playlist_id):
        """Get single playlist by ID (manual or auto)"""
        cursor = self.conn.cursor()
        try:
            return queries.get_playlist(cursor, playlist_id)
        finally:
            cursor.close()

    def update_playlist(self, playlist_id, name=None, is_auto=None, interval_minutes=None,
                       station_ids=None, max_songs=None, mode=None,
                       min_plays=None, max_plays=None, days=None):
        """Update playlist (manual or auto)"""
        return crud.update_playlist(self.cursor, self.conn, playlist_id, name, is_auto, interval_minutes,
                                   station_ids, max_songs, mode, min_plays, max_plays, days)

    def delete_playlist(self, playlist_id):
        """Delete playlist (manual or auto)"""
        return crud.delete_playlist(self.cursor, self.conn, playlist_id)

    def set_playlist_enabled(self, playlist_id, enabled):
        """Enable or disable playlist"""
        return crud.set_playlist_enabled(self.cursor, self.conn, playlist_id, enabled)

    def update_playlist_next_run(self, playlist_id, interval_minutes=None):
        """Update the next_run time for a playlist"""
        return crud.update_playlist_next_run(self.cursor, self.conn, playlist_id, interval_minutes)

    def record_playlist_update(self, playlist_id, success=True, last_updated=None, next_update=None):
        """Record a playlist update attempt

        Args:
            playlist_id: Playlist ID
            success: True if update succeeded, False if failed
            last_updated: Optional datetime for last_updated field
            next_update: Optional datetime for next_update field
        """
        # Use a fresh cursor to avoid threading issues
        cursor = self.get_cursor()
        try:
            return crud.record_playlist_update(cursor, self.conn, playlist_id, success, last_updated, next_update)
        finally:
            cursor.close()

    def get_due_playlists(self):
        """Get auto playlists that need updating"""
        return queries.get_due_playlists(self.cursor)

    def get_random_songs(self, station_ids=None, min_plays=1, max_plays=None, days=None, limit=50):
        """Get random songs from filtered results"""
        return queries.get_random_songs(self.cursor, station_ids, min_plays, max_plays, days, limit)

    def get_ai_playlist_songs(self, station_ids=None, min_plays=1, first_seen=None, last_seen=None):
        """Get songs for AI playlist generation

        Args:
            station_ids: Filter by stations (None or empty list = all stations)
            min_plays: Minimum play count (default: 1)
            first_seen: First seen date filter (ISO format string, e.g., "2026-01-01")
            last_seen: Last seen date filter (ISO format string, e.g., "2026-02-16")

        Returns:
            List of tuples: (artist_name, song_title)
        """
        # Use a fresh cursor to avoid 'Recursive use of cursors' error in multi-threaded Flask
        cursor = self.conn.cursor()
        try:
            return queries.get_ai_playlist_songs(cursor, station_ids, min_plays, first_seen, last_seen)
        finally:
            cursor.close()

    # ==================== CONNECTION MANAGEMENT ====================

    def close(self):
        """Close database connection"""
        if self.conn:
            self.conn.close()

    def get_thread_local_connection(self):
        """Create a new database connection for use in background threads

        This creates a fresh connection that won't block the main Flask database connection.
        Use this for background jobs to avoid blocking Flask requests.

        Returns:
            RadioDatabase instance with a new connection
        """
        thread_local_db = RadioDatabase(self.db_path)
        thread_local_db.conn = sqlite3.connect(self.db_path, check_same_thread=False)
        thread_local_db.cursor = thread_local_db.conn.cursor()
        thread_local_db.cursor.execute("PRAGMA foreign_keys = ON")
        return thread_local_db


__all__ = ['RadioDatabase']
